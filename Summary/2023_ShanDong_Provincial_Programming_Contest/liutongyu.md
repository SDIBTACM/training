# 比赛记录

## 6.3

    cwl鼻炎犯了，不想打代码，所以解题的任务安排在了我和lyh的身上。

    在cwl配VScode的环境的时候，我和lyh解完了a和b，c题没印象了，虽然是我敲的；之后我又把D题的思路跟lyh说了一下：
    
    就是0元的单独计数，如果取走的书的数目比0小，就是"impossible",如果书都被取走了，就输出"rich",在这之间的情况是先取前几个让他们加入sum，
    让他等于z取走的书的数目，那么剩下的钱肯定比之后的最小的价格小，所以后面的要排序，把最小的价格-1加进sum里就对了。
    但是在处理这第三种情况时我忘了让m减去价格为的0的书个数, 所以排序没排对，交错了一次。

## 6.4


   早上的时候我的母亲给我了发微信问我什么时候去找我。我才想起来我父母要来，一看时间安排，也就刚打完比赛有时间，才定在2点多南门。\
   没有告诉我妈我包满了的事情，所以我就不得不抱着一堆很沉的水果去艺体中心，带的水果除了樱桃和桃能分一分现场吃，其他的瓜什么的没法分，\
   所以我又得抱着一个大包从济南到烟台。。。。当然我还是得感谢我妈，我是第一次吃到枇杷~~还好我没把它当野果扔掉~~\
   早上的咖啡也是格外的甜，感觉自己在喝甜品，我非常不适应，脸部不由得挤出一副痛苦面具，还被毛老师抓了个现行haha\
   说完比较轻松的日常我们聊聊正式比赛的事\
    cwl 是从前面看的题，看到A，他就直接上了，拿到了一血。我和lyh是从后面开赛看的我们都看到了I题签到题，但是我们俩思路不同，lyh把机会让给了我，\
    结果我还少考虑了一种没有红色的情况错了一次；\
    交完两道题之后我们看榜上的人做G了，我们就跟着做了，我们发现对于满足条件的数的序号来说他们都是能连成一条递增的数字串的，而且大值一定在后面所以从后往前两两相加，\
    只要和大于0就加就行，后来看到题目的i-j=wi-wj才知道这是wi-i=wj-j的变式而已。\
    后来我们也不知道为什么跟D题杠上了，但是D题死活没做出来，我本来想的是能把一个人B背起来的A的v+w一定比B大，所以只要按v+w降序排序便知道了谁背人的能力最大\
    一开始没考虑到只要看能不能背前n/2速度慢的人就可以了，所以又麻烦的按速度升序排序了一遍，先解决速度小的人的问题。\
    但是这样没法得到最优解，因为我们不知道具体谁能背他，如果让最能背人的人背他，可能会让后面v+w更大的人没法被背走，所以我的题解一度陷入了停滞。\
    后来我们三个轮流敲了敲题后在11点多放弃了解这道题，cwl让我看E，我一看是让乘k倍和【n/k】的最大整数就想着用k进制来表示，\
    当时看样例就是n的前ni位只要是m的i(0<i<n)倍的前ni位，那么费用就是：(n的位数-ni)*b+（m的位数-ni）*b，\
    （例如：对于k=4时，101为1211,207为3033，而207*2为12132,207*3为21231,显然让1211变成12132比较容易）当然最后还得跟n的位数*b（即让n=0）比一下性价比；\
    但是这种方法要对1e18/k倍都遍历，加上我还对D不死心，后来没怎么想优化，就先跑去看D了；\
    D题我后来发觉可以先标记前n/2个慢的人，让他们按v+w从大到小排，然后可以背人的也是v+w从大到小排，看看能不能全背走\
    算最慢速度。但是我想到的时候lyh正好拿到了L的思路，在码题。所以我又去看E了，还是没看出来啥。\
    我是在最后十分钟的时候才拿到电脑，当时手都是颤抖的，没改好代码，赛后想了想最后一遍TOO LATE的代码还有问题，\
    当然lyh的L也寄了，听他说是没有特判1的情况，思路和给的题解一样，好嘛，难兄难弟。

## 感想

    寒碜，寒碜，很寒碜

## 补题

   D：一直没交赛后报告就是因为这个题没补好，现在好了，终于做出来了 QAQ\
    分析：还是不要尝试认为前n/2慢的都要背的好，你不知道到时候能不能都背的起来，有可能是一个中间速度不快但是体重比较高的把速度又慢又体重又重的人背走。\
    这题首先在于如何确定背与被背的人员。不是只要前n/2慢的都要被背。\
    再就是对于需要被背的人来说，他们的体重很重要，对于要背别人的人来说，他们的v+w很重要，\
    但两者没有直接得出一个人能背别人结论的依据(即便v1+w1大于一个人的w2但是会因w1<w2减速，减少后的速度符不符合标准我们就不得而知了)\
    而二分答案确实直接帮我们解决了这两个点。\
    首先小于答案速度(ans)的都是被背的人，其他的都是要背别人的人\
    然后因为有了具体的要求的速度所以背别人的人的能力v+w再减去ans就是他在满足速度的情况下能背的重量了，只要被背的人没有超过这个重量就得出了结论这个人能背他。\
    只要所有需要被背的人都被背了，那就成功了\
    思路：直接二分答案，对于每次查询，将速度比目标答案低的人划分到需要背的组，否则分到背人的组。\
    需要背的组按体重升序排列，背人的组按v+w-ans升序排列。d相当于背人的组的指针，遍历需要背的组的人只要当前的人能被背动那d++\
    （这个人背不动，看下一个能不能背动下一个需要背背的人）,背不动也d++(看下一个人能不能背动)。遇到d超限证明完成不了任务了，返回0。

    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    typedef long long ll;
    typedef struct A
    {
    int v;
    int w;
    int val;
    } A;
    A a[100010];
    int c[100010];
    int n;
    int key;
    std::vector<int>::iterator it;

    bool cmp(A a,A b)
    {
        return a.val<b.val;
    }
    bool cmp1(A a,A b)
    {
        return a.w<b.w;
    }
    int check()
    {
    vector<int>v;
    int cnt=0;
    for(int i=1;i<=n; i++)
    {
        if(a[i].v<key)
            c[++cnt]=a[i].w;
        else
            v.push_back(a[i].val-key);
    }
    sort(c+1,c+cnt+1);
    int d=0;
    int sz=v.size();
    for (int i = 1; cnt >= i; i++)
    {
        while(d<sz&&v[d]<c[i])
            d++;
        if(d==sz)
        return 0;
        else
        d++;
    }
    return 1;
    }
    void solve()
    {
    cin >> n;
    int vv;
    int lv=1e9;int rv=0;
    for (int i = 1; i <= n; i++)
    {
        cin >> vv >> a[i].w;
        a[i].v=vv;
        a[i].val = vv+ a[i].w;
        lv=min(vv,lv);
        if(rv<vv)
        rv=vv;
    }
    int ans=1;
    sort(a+1,a+n+1,cmp);
    while(lv<=rv)
    {
        key=(lv+rv)/2;
        if(check())
        {
            ans=key;
            lv=key+1;
        }   
        else
            rv=key-1;
    }
    cout<<ans<<endl;
    }
    ```
