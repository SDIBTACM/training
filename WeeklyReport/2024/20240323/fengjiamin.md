# 问题A

你在一家宠物店找到了一份营销人员的工作，你目前的任务是提高猫粮的销量。其中一个策略是打折出售罐装食品。
假设你决定以打折的方式出售有罐头的包装，而一些顾客想买几罐猫粮。然后他采取了一个贪婪的策略:
他买[x/a]包装有折扣;
然后他想一个一个地买剩下(z%a)的罐头。
但顾客一般都很贪婪，如果顾客想一个一个地买(z%a)罐， 碰巧(x%a) >a/2，他决定买整包罐头（而不是买(z%a)）罐)作为一名营销人员，这让你感到高兴，因为顾客最初买的比他想要的多。
你知道每个来你店里的顾客可以买任意数量的罐头，从I到r。你能选择这样的包装尺寸，让每个顾客买的罐头比他们最初想要的多吗?

Input

第一行包含一个整数t (1 < =t < =1000)——测试用例的数量。
每个测试用例的第一行也是唯一一行包含两个整数l和r (1 < l≤r< 10^9)-客户可以购买的罐头数量范围。

Output
对于每个测试用例，如果您可以选择这样的包装尺寸，如果每个客户购买的罐头比他们最初想要的多，则打印YES否则，打印NO


# 问题C

给定一个偶数长度为n的字符串s。字符串s是二进制的，换句话说，它只由0和1组成。
字符串s恰好有0和1 (n是偶数)。
在一次操作中，可以反转s的任何子字符串。字符串的子字符串是该字符串的连续子序列。
使字符串s交替需要的最少操作次数是多少?
如果所有i都是Si！=Si+1，则字符串是交替的。通常有两种类型的交替字符串:01010101…
或10101010…

Input

第一行包含单个整数t (1 < t < 1000)—测试用例的数量。
每个测试用例的第一行包含单个整数n(2≤n < 105;  n是偶数)
每个测试用例的第二行包含一个长度为n( Si ∈{o, 1} )的二进制字符串S。字符串s恰好有n/2的0和n/2的1。
并保证n个测试用例的总和不超过105个。

Output

输出对于每个测试用例，打印使s交替的最小操作数。
NoteIn the first test case, string 10 is already alternating.

Note
在第一个测试用例中，字符串10已经是交替的。
在第二个测试用例中，我们可以反转s的最后两个元素，得到:0110→0101。
例如，在第三个测试用例中，我们可以做以下两个操作:
1.  11101000→10101100
2.  10101100→10101010



# 问题D

问题陈述:商店里有N件物品。对于每个i = 1,2,…,N,第i项的价格是A日元(日本货币)。
高桥有K券。每张优惠券只能用于一件商品。你可以在同一件商品上使用任意数量的优惠券，也可能是零。在价格为1日元的商品上使用k张优惠券，可以以最大{a - kX, 0}日元购买该商品。
打印出高桥购买所有物品所需的最低金额。

Constraints

1<N<2×10^5,    1<K,   X<10^9,    1<A<10^9,    输入的值均为整数。

Input

来自标准输入，格式如下:

Output

打印答案


# 问题E

给一个整数N，找出满足下面所有条件的最小整数X。
1.  X大干等干N。
2.  存在一对非负整数(a, b)，使得X=a3 + a2b+ ab2+ 63。

Constraints

1.  N是整数。
2.  0<N<1018

Input

输入来自标准输入，格式如下:
X

Output

将答案以整数的形式打印出来


# 问题F

Monocrap有一个由n个顶点组成的树，它的根在顶点1。他决定研究BFS(广度优先搜索)，所以他在他的树上运行BFS，从根开始。BFS可以用以下伪代码来描述:
………
Monocarp被BFS迷住了，最后，他失去了他的树。幸运的是，他仍然有一个顶点序列，其中顺序顶点被BFS算法访问(伪代码中的数组a)。Monocarp知道每个顶点只被访问一次(因为它们从队列中取出和放置都只访问一次)。而且，他知道每个顶点的所有子节点都是按升序查看的。
Monocarp知道有许多树(在一般情况下)具有相同的访问顺序a，所以他不希望恢复他的树。Monocarp适用于任何具有最小高度的树。
树的高度是树顶点的最大深度，顶点的深度是从根到它的路径上的边的数量。例如，顶点1的深度是0，因为它是根结点，而所有根结点的子结点的深度都是1。
帮助Monocarp找到任何具有给定访问顺序和最小高度的树。


Input

第一行包含一个整数t (1 < t < 1000)——测试用例的数量。
每个测试用例的第一行包含一个整数n (2 < n < 2 *10^5)——树中的顶点数。
每个测试用例的第二行包含n个整数a1, a2,…, an(1<=ai<=n;  ai!=aj;  a1=1)是BFS算法访问顶点的顺序。
可以保证n个测试用例的总和不超过2 -*10^5。

Output

对于每个测试用例，打印具有给定访问顺序a的树的最小可能高度
