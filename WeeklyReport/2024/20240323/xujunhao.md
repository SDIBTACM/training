# 本周完成
## 补了两个选拔赛的题
## 学了点搜索，dfs，bfs，学不明白。。。。。
## 翻译了未作出的题目，翻译如下：
### E的翻译：
给定一个整数 N，找出最小的整数 X，满足以下所有条件：1.X 大于等于 N。2.存在一对非负整数 (a, b)，使得 X = a^3 + a^2 * b + a * b^2 + b^3。约束 N是一个整数，0 ≤ N ≤ 10^18。对于任何整数 X，如果 9 ≤ X 
≤ 14，都不存在 (a, b) 满足题目中的条件。当 X = 15 时，(a, b) = (2, 1) 满足条件。输入和输出可能不适合存储在32位整数类型中。
### F题的翻译：
Monocarp 有一棵树，这棵树由 n 个顶点组成，并且以顶点 1 为根。他决定研究广度优先搜索（BFS），所以他从根开始，对这棵树执行了 BFS。BFS 可以通过以下伪代码来描述：
```
a = [] # the order in which vertices were processed
q = Queue()
q.put(1) # place the root at the end of the queue
while not q.empty():
    k = q.pop() # retrieve the first vertex from the queue
    a.append(k) # append k to the end of the sequence in which vertices were visited
    for y in g[k]: # g[k] is the list of all children of vertex k, sorted in ascending order
        q.put(y)
```
Monocarp 对 BFS 非常着迷，以至于最终他失去了这棵树。幸运的是，他仍然有一个顶点序列，BFS 算法（伪代码中的数组 a）访问顶点的顺序。Monocarp 知道每个顶点只被访问过一次（因为它们被放置和从队列中取出恰好一次）。此外，他知道每个顶点的所有子项都是按升序查看的。Monocarp 对 BFS 如此着迷，以至于最后他弄丢了自己的树。幸运的是，他仍保留了一个顶点序列，这个序列是按照 BFS 算法访问顶点的顺序（即伪代码中的数组 a）。Monocarp 知道每个顶点只被访问了一次（因为它们只被放入和从队列中取出了一次）。
同时，他也知道每个顶点的所有子节点都是按升序被访问的。
Monocarp 明白，通常会有许多树（在一般情况下）具有相同的访问顺序a，因此他不指望能恢复自己的树。Monocarp 对任何具有最小高度的树都感到满意。
树的高度是指树中顶点的最大深度，而顶点的深度是从根到该顶点的路径中的边数。例如，顶点1的深度是0，因为它是根，而根的所有子节点的深度都是1。
请帮助 Monocarp 找到具有给定访问顺序a的任意树，并且该树的高度最小。
每个测试用例的第二行包含n个整数a1,a2,…,an（1≤ai≤n；ai≠aj；a1=1）——BFS算法访问顶点的顺序。
保证所有测试用例中n的总和不超过2⋅10^5。
输出最小可能高度。
### G题的翻译：
我们有一个N×N的棋盘。用(i,j)来表示从棋盘顶部数起的第i行，以及从左侧数起的第j列的那个方格。
棋盘是由N个字符串S_i描述的。字符串S_i的第j个字符S_{i,j}代表以下意义：如果S_{i,j} = .，那么方格(i,j)是空的。
如果S_{i,j} = #，那么方格(i,j)被一个白色的兵占据，这个兵不能被移动或移除。我们在棋盘上放了一个白色的象，位于坐标 (A_x, A_y)。
根据国际象棋的规则，找出将这个象从 (A_x, A_y) 移动到 (B_x, B_y) 所需的最小步数。
如果无法将其移动到 (B_x, B_y)，则返回 -1。棋盘上的一个白色象位于坐标 (i, j)，它可以在一步内移动到以下位置。
对于每个正整数 d，它可以满足以下条件时移动到 (i+d, j+d)：
坐标 (i+d, j+d) 在棋盘范围内。
对于每个正整数 l（其中 1 ≤ l ≤ d），坐标 (i+l, j+l) 不被白方兵占据。
对于每个正整数 d，它可以满足以下条件时移动到 (i+d, j-d)：
坐标 (i+d, j-d) 在棋盘范围内。
对于每个正整数 l（其中 1 ≤ l ≤ d），坐标 (i+l, j-l) 不被白方兵占据。
对于每个正整数 d，它可以满足以下条件时移动到 (i-d, j+d)：
坐标 (i-d, j+d) 在棋盘范围内。
对于每个正整数 l（其中 1 ≤ l ≤ d），坐标 (i-l, j+l) 不被白方兵占据。
对于每个正整数 d，它可以满足以下条件时移动到 (i-d, j-d)：
坐标 (i-d, j-d) 在棋盘范围内。
对于每个正整数 l（其中 1 ≤ l ≤ d），坐标 (i-l, j-l) 不被白方兵占据。
其中：N 表示白色兵的数量。
A_x A_y 表示白色象的初始位置坐标 (A_x, A_y)。
B_x B_y 表示目标位置坐标 (B_x, B_y)，象需要移动到这里。
S_1 到 S_N 表示 N 个白色兵的位置坐标，每个坐标的格式为 x y。
输出：
如果白色象能够按照国际象棋的规则从 (A_x, A_y) 移动到 (B_x, B_y)，则输出所需的最小步数。
如果无法移动，则输出 -1。输出，打印答案。
### H题的翻译:
厨师 Monocarp 刚刚把 n 道菜放进了烤箱。他知道第 i 道菜的最佳烹饪时间是 ti 分钟。
在任意正整数分钟 T，Monocarp 最多只能从烤箱中取出一道菜。如果第 i 道菜在某一分钟 T 被取出，那么它的不愉快值就是 |T−ti| —— 即 T 和 ti 之间的绝对差值。一旦菜肴从烤箱中取出，就不能再放回去了。
Monocarp 需要把所有的菜肴都从烤箱中取出来。Monocarp 能够获得的最小总不愉快值是多少？
输入：第一行包含一个整数 q（1≤q≤200） —— 测试用例的数量。
接下来是 q 个测试用例。
每个测试用例的第一行包含一个整数 n（1≤n≤200） —— 烤箱中菜肴的数量。
每个测试用例的第二行包含 n 个整数 t1,t2,…,tn（1≤ti≤n） —— 每道菜肴的最佳烹饪时间。
所有 q 个测试用例中 n 的总和不超过 200。
输出：对于每个测试用例，输出一个整数 —— 当 Monocarp 把所有菜肴从烤箱中取出时，他能获得的最小总不愉快值。记住 Monocarp 只能在正整数分钟取出菜肴，并且每分钟最多只能取出一道菜。说明
在第一个例子中，Monocarp 可以在第 3、1、5、4、6、2 分钟分别取出菜肴。这样，总不愉快值将会是 |4−3|+|2−1|+|4−5|+|4−4|+|6−5|+|2−2|=4。
在第二个例子中，Monocarp 可以在第 4、5、6、7、8、9、10 分钟分别取出菜肴。
在第三个例子中，Monocarp 可以在第 1 分钟取出菜肴。
在第四个例子中，Monocarp 可以在第 5、1、2、4、3 分钟分别取出菜肴。
在第五个例子中，Monocarp 可以在第 1、3、4、5 分钟分别取出菜肴。
# 下周计划
## 补补选拔赛3的题目，继续学学搜索吧。。。
