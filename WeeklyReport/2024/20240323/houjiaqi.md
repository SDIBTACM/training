**E - 2 变量函数 **
给定一个整数N，找到满足以下所有条件的最小整数X。
X大于或等于N。
存在一对非负整数(a, b)，使得X等于a^3 + a^2b + ab^2 + b^3。
N是一个整数，0<=N<=1e18.

**F - 最小高度树**
Monocarp有一棵由n个顶点组成的树，且根节点为顶点1。他决定学习广度优先搜索（BFS），于是他从根节点开始对这棵树进行了BFS遍历。BFS的伪代码可以描述如下：
`a = [] # the order in which vertices were processed
q = Queue()
q.put(1) # place the root at the end of the queue
while not q.empty():
    k = q.pop() # retrieve the first vertex from the queue
    a.append(k) # append k to the end of the sequence in which vertices were visited
    for y in g[k]: # g[k] is the list of all children of vertex k, sorted in ascending order
        q.put(y)`

Monocarp对BFS如此着迷，以至于最后他失去了自己的树。幸运的是，他仍然记得BFS算法遍历顶点的顺序（即伪代码中的数组a）。Monocarp知道每个顶点只被访问了一次（因为它们被精确地放入和从队列中取出了一次）。他还知道每个顶点的所有子节点都是按照升序访问的。
Monocarp知道，具有相同访问顺序a的树（在一般情况下）有很多，所以他并不希望恢复原来的树。Monocarp接受任何具有最小高度的树。
树的高度是指树中顶点的最大深度，而顶点的深度是指从根节点到该顶点的路径上的边数。例如，顶点1的深度是0，因为它是根节点，所有根节点的子节点的深度都是1。
请帮助Monocarp找到具有给定访问顺序a和最小高度的任意一棵树。

**G - 主教 2**
我们有一个N×N的棋盘。用(i,j)表示从上往下数第i行、从左往右数第j列的格子。
棋盘由N个字符串S_i描述。字符串S_i的第j个字符S_{i,j}代表以下意义：
如果S_{i,j}是.，那么格子(i,j)是空的。
如果S_{i,j}是#，那么格子(i,j)被一个白色的兵占据，这个兵不能移动或移除。
我们在格子(A_x, A_y)上放置了一个白色的象。
根据国际象棋的规则（参见注释），找出将这个象从(A_x, A_y)移动到(B_x, B_y)所需的最小步数。
如果无法移动到(B_x, B_y)，则输出-1。

注释
在棋盘上的格子(i,j)上的白色象可以在一步内移动到以下位置：

对于每个正整数d，如果满足以下条件，它可以移动到(i+d,j+d)：
格子(i+d,j+d)在棋盘上。
对于每个正整数l≤d，(i+l,j+l)不被白色的兵占据。

对于每个正整数d，如果满足以下条件，它可以移动到(i+d,j-d)：
格子(i+d,j-d)在棋盘上。
对于每个正整数l≤d，(i+l,j-l)不被白色的兵占据。

对于每个正整数d，如果满足以下条件，它可以移动到(i-d,j+d)：
格子(i-d,j+d)在棋盘上。
对于每个正整数l≤d，(i-l,j+l)不被白色的兵占据。

对于每个正整数d，如果满足以下条件，它可以移动到(i-d,j-d)：
格子(i-d,j-d)在棋盘上。
对于每个正整数l≤d，(i-l,j-l)不被白色的兵占据。
2 ≤ N ≤ 1500
1 ≤ Ax, Ay ≤ N
1 ≤ Bx, By ≤ N
(Ax, Ay) ≠ (Bx, By)
Si 是一个长度为 N 的字符串，由 . 和 # 组成。
S{Ax, Ay} = .
S{Bx, By} = .

**H - 首席单果皮**
Monocarp厨师刚刚把n道菜肴放进了烤箱。他知道第i道菜肴的最佳烹饪时间是ti分钟。
在任何正整数分钟T，Monocarp最多只能从烤箱中拿出一道菜。如果第i道菜肴在某一分钟T被拿出，那么它的不愉快值就是|T-ti|——T和ti之间的绝对差值。一旦菜肴从烤箱中取出，就不能再放回去了。
Monocarp需要将所有的菜肴都从烤箱中取出。Monocarp能获得的最小总不愉快值是多少？
输入
第一行包含一个整数q（1≤q≤200）——测试用例的数量。
接下来是q个测试用例。
每个测试用例的第一行包含一个整数n（1≤n≤200）——烤箱中的菜肴数量。
每个测试用例的第二行包含n个整数t1,t2,…,tn（1≤ti≤n）——每道菜肴的最佳烹饪时间。
所有q个测试用例中n的总和不超过200。
输出
对于每个测试用例，输出一个整数——当Monocarp将所有菜肴从烤箱中取出时，他能获得的最小总不愉快值。请注意，Monocarp只能在正整数分钟取出菜肴，并且任何一分钟内最多只能取出一道菜。

本周感想：
高等数学，离散数学，大学物理，要学好。 
dfs和bfs两种算法，难懂，只能做些表面题。
选拔赛英语题意不好理解，限制条件还难想到，需要继续努力。
下周计划：
复习物理，离散数学，准备测试。
多记些英语单词。
复习dfs,bfs,素数筛等。
