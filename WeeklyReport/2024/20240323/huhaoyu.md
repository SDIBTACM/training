# 选拔赛2翻译
## F - Minimal Height Tree （最小高度树）
Monocarp 有棵树,由n个顶点组成扎根于1个顶点。他决定研究BFS（广度优先搜索），所以他在他的树上运行BFS，从根开始。BFS 可以用以下伪代码来描述：
Monocarp 对 BFS 非常着迷，以至于最终他失去了这棵树。幸运的是，他仍然有一个顶点序列，BFS 算法（伪代码中的数组 a）访问顶点的顺序。Monocarp 知道每个顶点只被访问过一次（因为它们被放置和从队列中取出恰好一次）。此外，他知道每个顶点的所有子项都是按升序查看的。
Monocarp 知道有许多树（在一般情况下）具有相同的访问顺序 a，所以他不希望恢复他的树。Monocarp 可以与任何具有最小高度的树搭配使用。
树的高度是树顶点的最大深度，顶点的深度是从根到它的路径中的边数。例如，顶点 1 的深度是 0，因为它是根，并且所有根的子项的深度都是 1。
帮助 Monocarp 找到任何具有给定访问顺序的树和最小高度。
### 输入 
第一行包含单个整数 t（1≤t≤1000） — 测试用例的数量。
每个测试用例的第一行包含一个整数 n（2≤n≤2⋅105） — 树中的顶点数。
每个测试用例的第二行包含 n整数 a1，a2,...,an （1≤ai≤n; ai≠aj; a1=1） — BFS 算法访问顶点的顺序。
可以保证 n 的总和超过测试用例不超过 2⋅105。
### 输出
对于每个测试用例，使用给定的访问顺序打印树的最小可能高度。
###注意 
在第一个测试用例中，只有一棵树具有给定的访问顺序：
在第二个测试用例中，也只有一棵树具有给定的访问顺序：
在第三个测试用例中，具有给定访问顺序的最优树如下所示：
## G - Bishop 2 （象）
### 问题陈述
我们有一个 N×N 棋盘。设 （i，j）表示从此板顶部开始的第 i 行和从此板左侧开始的第 j 列的正方形。
该板由 N 字符串 Si 描述。
字符串 Si， Si，j 的第 j 个字符表示以下内容。
如果 Si,j=.，则平方 （i，j）为空。
如果 Si,j=#，则方块 （i，j）被白色棋子占据，无法移动或移除。
我们在广场上放了一个象(Ax，Ay).
根据国际象棋规则，找到将这位象从（Ax，Ay）移动到（Bx，By）所需的最小步数。
如果无法将其移动到 （Bx，By），输出 -1。
方格上的象（i，j）可以一举走到以下位置。 
对于每个正整数 dd，如果满足所有条件，它可以变为 （i+d，j+d）。板中存在正方形（i+d，j+d）。 
对于每个正整数 l≤dl≤d，（i+l，j+l）不被白色棋子占据。 
对于每个正整数 dd，如果满足所有条件，它可以变为 （i+d，j−d）。正方形 （i+d，j−d）存在于板中。对于每个正整数 l≤dl≤d，（i+l，j−l）不被白色棋子占据。 
对于每个正整数 dd，如果满足所有条件，它可以变为 （i−d，j+d）。正方形 （i−d，j+d）存在于板中。对于每个正整数 l≤dl≤d，（i−l，j+l）不被白色棋子占据。
对于每个正整数 dd，如果满足所有条件，它可以变为 （i−d，j−d）。正方形 （i−d，j−d）存在于板中。对于每个正整数 l≤dl≤d，（i−l，j−l）不被白色棋子占据。 
## H - Chef Monocarp （主厨 Monocarp） 
主厨 Monocarp 刚刚将 n 道菜放入烤箱。他知道第 i 道菜的最佳烹饪时间等于 ti。在任何正整数分钟 T Monocarp 只能从烤箱中取出一道菜。如果第 i 个盘子在某个分钟 T 熄灭，那么它的不愉快值是 |T−ti|————T 和 ti 之间的绝对差值。一旦盘子从烤箱里出来，它就不能再进去。
Monocarp 应该把所有的盘子都从烤箱里拿出来。Monocarp 可以获得的最小总不愉快值是多少？
### 输入
第一行包含单个整数 q（1≤t≤200） — 测试用例的数量。
然后 q
测试用例如下。
测试用例的第一行包含单个整数 n（1≤N≤200） — 烤箱中的盘子数量。
测试用例的第二行包含 n整数 t1，t2,...,tn （1≤ti≤n） — 每道菜的最佳烹饪时间。
n 的总和在所有 Q 测试用例中不超过 200 个。
### 输出
为每个测试用例打印一个整数——这是 Monocarp 将所有菜肴从烤箱中取出时可以获得的最小总不愉快值。请记住，Monocarp 只能在正整数分钟时将盘子放出来，并且在任何分钟都不能超过一个盘子。
# 总结
做了挺多题目了，英文题头疼
# 计划
学学高数，离散数学
