# 补题C  
```ruby

#include<stdio.h>
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        int sum1=0,sum2=0;
        char a[200000];
        int n;
        scanf("%d",&n);
        scanf("%s",a);
        for(int i=0;i<n;i++)
        {
            if(a[i]=='1'&&a[i+1]=='1')
                sum1++;
            if(a[i]=='0'&&a[i+1]=='0')
                sum2++;
        }
        if(sum1>sum2)
            printf("%d\n",sum1);
        else
            printf("%d\n",sum2);
    }
    return 0;
}


```
# 补题D
```ruby

#include<stdio.h>
#include <algorithm>
using namespace std;
long long sum=0,n,x,k,i;
int a[200000];
int main()
{
    scanf("%lld%lld%lld",&n,&k,&x);
    for(i=0;i<n;i++)
    {
        scanf("%d",&a[i]);
        sum+=a[i];
        while(a[i]>x&&k!=0)
        {
            sum-=x;
            a[i]-=x;
            k--;
        }//让每个a都小于优惠券
    }
    if(k>0)//如果有多的优惠券
    {
        sort(a,a+n);
        for(i=n-1;i>=0&&k>0;i--)
        {
            sum-=a[i];
            k--;
        }
    }
    printf("%lld\n",sum);
    return 0;
}


```
# 翻译  
## E  
给一个整数N，找出满足下面所有条件的最小整数X  
X>=N  
存在一对非负整数(a, b)，使得X=a^3 +a^2b+ab^2+b^3X  
N是整数  
0<=N<=10^18  
## F  
Monocarp 有一棵树，由n顶点，并植根于顶点1他决定研究BFS（广度优先搜索）  
所以他在他的树上运行BFS，从根开始。BFS 可以用以下伪代码来描述    
Monocarp 对 BFS 非常着迷，以至于最终他失去了这棵树。幸运的是，他仍然有  
一个顶点序列，BFS 算法（伪代码中的数组 a）访问顶点的顺序。   
Monocarp 知道每个顶点只被访问过一次（因为它们被放置和从队列中取出恰好一次）  
此外，他知道每个顶点的所有子项都是按升序查看的。  
Monocarp 知道有许多树（在一般情况下）具有相同的访问顺序一个  所以他不希  
望恢复他的树。Monocarp 可以与任何具有最小高度的树搭配使用。  树的高度是树  
顶点的最大深度，顶点的深度是从根到它的路径中的边数  
例如，顶点的深度1  是0因为它是根，而所有根的子项的深度都是1  
帮助 Monocarp 找到任何具有给定访问顺序的树一个  和最小高度。  
输入  
第一行包含一个整数t (1 < t < 1000)——测试用例的数量。 每个测试用例的第一行包  
含一个整数n (2 < n < 2 *10^5)——树中的顶点数。 每个测试用例的第二行包含n个整  
数a1, a2,…, an(1<=ai<=n; ai!=aj; a1=1)是BFS算法访问顶点的顺序。 可以保证n  
个测试用例的总和不超过2 -*10^5。  
输出  
对于每个测试用例，打印具有给定访问顺序a的树的最小可能高度  
## G  
我们有一个棋盘。让我们表示从此板顶部开始的第 -行和从此板左侧开始的第 - 列的正方形。  
该板由字符串描述。  
字符串 的第 -th 个字符表示以下内容。  
N*N(i,j)ijNSijSiSij  
如果 ，则正方形为空sij=(i,j)  
如果 ，则方块被白色棋子占据，该棋子无法移动或移除。sij=#(i,j)  
我们在广场上放了一位白人主教.  
根据国际象棋规则，找到将这位主教从移动到移动所需的最小步数（见注释）。  
如果无法将其移动到 ，请改为报告。  
(ax,ay)(bx,by)  
## H  
主厨 Monocarp 刚刚把n将盘子放入烤箱。他知道我-th 菜肴的最佳烹饪时间等于t我  
纪要。  
在任何正整数分钟TMonocarp 最多只能从烤箱中取出一道菜。如果我第道菜在某分钟熄灭T  
，那么它的不愉快值是|T−t我| 两者之间的绝对差异T和t我一旦盘子从烤箱里出来，它就不能再进去。  
Monocarp 应该把所有的盘子都从烤箱里拿出来。Monocarp 可以获得的最小总不愉快值是多少？ 
输入  
1<=q<=200  
1<=n<=200  
t1,t2,t3.........  
输出  
为每个测试用例打印一个整数——这是 Monocarp 将所有菜肴从烤箱中取出时可以获得的最小总不愉快值  
。请记住，Monocarp 只能在正整数分钟时将盘子放出来，并且在任何分钟都不能超过一个盘子  


  一共写了四道下次再接再厉！！！！
