#
##
###
...
**c-Reverse Binary Strings**

给你一个偶数长度n的字符串s。字符串s是二进制的，换句话说，只由0和1组成。
字符串s恰好有0和1（n是偶数）。
在一个操作中，你可以反转s的任何子字符串。字符串的子字符串是该字符串的连续子序列。
要使字符串s交替，最少需要多少次操作？如果所有i都是sisi+1，那么一个字符串就是交替的，一般有两种交替
的字符串：01010101・或10101010・

输入

第一行包含单个整数t（1＜t＜1000）—一测试用例的数量。

每测试案例之第一线contains a单身整数n（2≤n≤105)；一弦的长度。

每个测试用例的第二行包含一个长度为n（siE£0,1）的二进制字符串S。字符串s恰好有0和1。

它保证n/测试用例的总和不超过105。

输出

对于每个测试用例，打印使s交替的最小操作数。
请注意

在第一个测试用例中，字符串10已经是交替的。

在第二个测试用例中，我们可以，例如，反转s的最后两个元素，得到：0110-0101。

在第三个测试用例中，我们可以，例如，做以下两个操作：

1.11101000→10101100；
2.10101100→10101100。

**D-coupon**

问题陈述

商店里有N件商品。对于每一个i=1,2，…..，N，第i个物品的价格是A，日元（日本货币）。
高桥有K券。
每张优惠券只能用于一件商品。你可以在同一件商品上使用任意数量的优惠券，也可能是零项。在一件价格为1日元的商品上使用k张优惠券，你可以花100日元买到它。
打印出高桥购买所有物品所需的最低金额。

约束

• 1<N<2X105

• 1< k, x <109

•1<A>109

・輸入中的所有値都是整数。

输入

输出

通过在第1件商品上使用1张优惠券，在第3件商品上使用1张优惠券，在第5件商品上使用2张优惠券，高桥可以：

•以max｛A1-X，0｝=1日元的价格购买第1件物品，

•以max｛A2，OF）=3日元购买第二件物品，

• 购买第三件物品max｛A3×，0|=3日元，

•以max｛A4X，0=5日元购买第4件，

• 购买第5件max｛a4-2x，0|=0日元，总共1+3+3+5+0=12日元，这是可能的最小值。

**E-2**

问题陈述

给定一个整数N，找出满足下面所有条件的最小整数X。有一对非负整数（a,b）使得X=a3+
a2b + ab2+b3。

'X大于等于N。

约束

•N是一个整数。

• O<N<1018

**F-minimal hight tree**

Monocarp有一个由n个顶点组成的树，并且扎根于顶点1。他决定研究广度优先搜索（BFS），所以他在他的树上运行BFS，从根开始。BFS可以用以下伪代码描述：
Monocarp被BFS迷住了，最后，他失去了他的树。幸运的是，他仍然有一个顶点序列，其中顺序顶点被BFS算法访问（伪代码中的数组a）。Monocarp知道每个顶点只被访问了一次（因为它们从队列中被放置和取出正好一次）。同时，他知道每个顶点的所有子节点都是按升序被查看的。
Monocarp知道有许多树（在一般情况下）具有相同的访问顺序a，所以他不希望恢复他的树。Monocarp可以接受任何具有最小高度的树。
树的高度是树顶点的最大深度，顶点的深度是th树的高度是树顶点的最大深度，顶点的深度是从根到它的路径上的边数。例如，顶点1的深度为0，因为它是根，而所有根的子结点的深度都是1。
帮助Monocarp找到任何具有给定访问顺序和最小高度的树。

输入

第一行包含单个整数t（1＜t＜1000）—一测试用例的数量。
每个测试用例的第一行包含单个整数n（2≤n≤2•105）—一树中的顶点数。
每个测试用例的第二行包含n个整数al, a2，…an（1≤a≤n;aiFaj;al= 1）-BFS算法访问顶点的顺序。
可以保证n个测试用例的总和不超过2-105。

输出

对于每个测试用例，打印具有给定访问顺序a的树的最小可能高度。

**G-bishop 2**

问题陈述

我们有NXN的棋盘。让我们从i到j，从上到下，从上到下，从上到下，从上到下，从上到下，从上到下，从上到下从这个板的左边开始。这个板子用N串S来描述。
字符串“Si, Si」”的第j个字符表示以下内容。

•如果Si,j=，则正方形（ij为空。

如果Sij=#，则方格（ij被白兵占据，白兵无法移动或移除。

我们在方块上放了一个白色的象（Ax，Ay）。根据国际象棋规则（见注意事项），找出将这个象从（Ax，Ay）移动到（Bz, By）所需的最小移动数。
如果不能移动到（Bz, By），则报告-1。

注意事项

方块（i,j）上的白象可以在一次移动中走到以下位置。
对于每一个正整数d，如果满足所有条件，它可以走到（i+d,j+d）。
0正方形（i+ d,j+d）存在于棋盘中。
o对于每一个正整数l≤d，（i+l,j+l）不被白兵占据。
对于每一个正整数d，在满足所有条件的情况下，可以走到（i+d,j-d）。
0正方形（i+ d,j-d）存在于棋盘中。
o对于每一个正整数I≤d，（i+lj-l）不被白兵占据。
对于每一个正整数d，如果满足所有条件，它可以到（i-d,j+d）。
◎正方形（i-d,j+d）存在于棋盘中。
o对于每一个正整数I≤d，（i-l,j+l）不被白兵占据。
对于每一个正整数d，在满足所有条件的情况下，它可以走到（i-d,j-d）。
o正方形（i-d,j-d）存在于棋盘中。
o对于每一个正整数I≤d，（i-l,j-1）不被白兵占据。

约束

2<N<1500
• 1 < Az, Ay < N
• 1<Bz, By<N
•（AZ, Ay） + （Bz, By），年代；是长度为N的字符串，由。和#。
• SAx,Ay=.
• SBx. By=.

**G-chef momocarp**

Monocarp厨师刚把n道菜放进烤箱。他知道第i道菜的最佳烹饪时间是i-th分钟。

在任意正整数分钟内，Monocarp最多只能从烤箱中取出一道菜。如果第i道菜是在某分钟T放出来的，那么它的不愉快值是|T-ti|-T和ti之间的绝对差。这道菜一旦出了烤箱，就再也放不进去了。
Monocarp应该把所有的盘子从烤箱里拿出来。Monocarp能得到的最小总价值是多少？

输入

第一行包含单个整数q（1≤q≤200）—一测试用例的数量。
然后是q个测试用例。
测试用例的第一行包含一个单个整数n（1<n＜200）—一烤箱里盘子的数量。
测试用例的第二行包含n个整数t1,t2，…，tn（1≤ti≤n）——每道菜的最佳烹饪时间。
n除以所有q个测试用例的和不超过200。

输出

为每个测试用例打印一个整数——Monocarp将所有盘子从烤箱中取出时所能获得的最小不愉快值。请记住，Monocarp只能在正整数分钟内把菜端出来，而且每分钟不能超过一道菜。

请注意

在第一个例子中，Monocarp可以在3分钟、1分钟、5分钟、4分钟、6分钟、2分钟的时候把菜端出来。这样总的不愉快值将是|4-3|+|2-1|+14-5|+14-4|+|6-5|+|2-2|=4。

在第二个例子中，Monocarp可以在4分钟、5分钟、6分钟、7分钟、8分钟、9分钟、10分钟的时候把菜端出来。

在第三个例子中，Monocarp可以在第1分钟把菜端出来。


例二请注意

在第一个例子中，Monocarp可以在3分钟、1分钟、5分钟、4分钟、6分钟、2分钟的时候把菜端出来。这样总的不愉快值将是|4-3|+|2-1|+14-5|+14-4|+16-5|+|2-2|=4。
在第二个例子中，Monocarp可以在4分钟、5分钟、6分钟、7分钟、8分钟、9分钟、10分钟的时候把菜端出来
在第三个例子中，Monocarp可以在第1分钟把菜端出来。
在第四个例子中，Monocarp可以在5分钟、1分钟、2分钟、4分钟、3分钟的时候把盘子端出来
在第五个例子中，Monocarp可以在1分钟、3分钟、4分钟、5分钟的时候把菜端出来。






...
