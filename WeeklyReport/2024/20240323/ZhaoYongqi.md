# 选拔赛2翻译
## F - Minimal Height Tree （最小高度树）
Monocarp 有一棵树，由 n 个顶点组成，扎根于 1 个顶点。他决定研究BFS（广度优先搜索），所以他在他的树上运行BFS，从根开始。BFS 可以用以下伪代码来描述：
```c++
a = [] # 处理顶点的顺序
q = Queue（）
q.put（1） # 将根放在队列的末尾
while not q.empty（）：
    k = q.pop（） # 从队列中检索第一个顶点
    a.append（k） # 将 k 追加到访问顶点的序列的末尾
    for y in g[k]：# g[k] 是顶点 k 的所有子项的列表，按升序排序
        q.put（y）

```
Monocarp 对 BFS 非常着迷，以至于最终他失去了这棵树。幸运的是，他仍然有一个顶点序列，BFS 算法（伪代码中的数组 a）访问顶点的顺序。Monocarp 知道每个顶点只被访问过一次（因为它们被放置和从队列中取出恰好一次）。此外，他知道每个顶点的所有子项都是按升序查看的。
Monocarp 知道有许多树（在一般情况下）具有相同的访问顺序 a，所以他不希望恢复他的树。Monocarp 可以与任何具有最小高度的树搭配使用。
树的高度是树顶点的最大深度，顶点的深度是从根到它的路径中的边数。例如，顶点 1 的深度是 0，因为它是根，并且所有根的子项的深度都是 1。
帮助 Monocarp 找到任何具有给定访问顺序的树和最小高度。

### 输入 
第一行包含单个整数 t（1≤t≤1000） — 测试用例的数量。
每个测试用例的第一行包含一个整数 n（2≤n≤2⋅105） — 树中的顶点数。
每个测试用例的第二行包含 n整数 a1，a2,...,an （1≤ai≤n; ai≠aj; a1=1） — BFS 算法访问顶点的顺序。
可以保证 n 的总和超过测试用例不超过 2⋅105。

### 输出
对于每个测试用例，使用给定的访问顺序打印树的最小可能高度。

###注意 
在第一个测试用例中，只有一棵树具有给定的访问顺序：
在第二个测试用例中，也只有一棵树具有给定的访问顺序：
在第三个测试用例中，具有给定访问顺序的最优树如下所示：

## G - Bishop 2 （象）
### 问题陈述
我们有一个 N×N 棋盘。设 （i，j）表示从此板顶部开始的第 i 行和从此板左侧开始的第 j 列的正方形。
该板由 N 字符串 Si 描述。
字符串 Si， Si，j 的第 j 个字符表示以下内容。
如果 Si,j=.，则平方 （i，j）为空。
如果 Si,j=#，则方块 （i，j）被白色棋子占据，无法移动或移除。
我们在广场上放了一个象(Ax，Ay).
根据国际象棋规则，找到将这位象从（Ax，Ay）移动到（Bx，By）所需的最小步数。
如果无法将其移动到 （Bx，By），输出 -1。

方格上的象（i，j）可以一举走到以下位置。 

对于每个正整数 dd，如果满足所有条件，它可以变为 （i+d，j+d）。板中存在正方形（i+d，j+d）。 

对于每个正整数 l≤dl≤d，（i+l，j+l）不被白色棋子占据。 

对于每个正整数 dd，如果满足所有条件，它可以变为 （i+d，j−d）。正方形 （i+d，j−d）存在于板中。对于每个正整数 l≤dl≤d，（i+l，j−l）不被白色棋子占据。 

对于每个正整数 dd，如果满足所有条件，它可以变为 （i−d，j+d）。正方形 （i−d，j+d）存在于板中。对于每个正整数 l≤dl≤d，（i−l，j+l）不被白色棋子占据。

对于每个正整数 dd，如果满足所有条件，它可以变为 （i−d，j−d）。正方形 （i−d，j−d）存在于板中。对于每个正整数 l≤dl≤d，（i−l，j−l）不被白色棋子占据。 

## H - Chef Monocarp （主厨 Monocarp） 

主厨 Monocarp 刚刚将 n 道菜放入烤箱。他知道第 i 道菜的最佳烹饪时间等于 ti。在任何正整数分钟 T Monocarp 只能从烤箱中取出一道菜。如果第 i 个盘子在某个分钟 T 熄灭，那么它的不愉快值是 |T−ti|————T 和 ti 之间的绝对差值。一旦盘子从烤箱里出来，它就不能再进去。
Monocarp 应该把所有的盘子都从烤箱里拿出来。Monocarp 可以获得的最小总不愉快值是多少？
### 输入
第一行包含单个整数 q（1≤t≤200） — 测试用例的数量。
然后 q
测试用例如下。
测试用例的第一行包含单个整数 n（1≤N≤200） — 烤箱中的盘子数量。
测试用例的第二行包含 n整数 t1，t2,...,tn （1≤ti≤n） — 每道菜的最佳烹饪时间。
n 的总和在所有 Q 测试用例中不超过 200 个。
### 输出
为每个测试用例打印一个整数——这是 Monocarp 将所有菜肴从烤箱中取出时可以获得的最小总不愉快值。请记住，Monocarp 只能在正整数分钟时将盘子放出来，并且在任何分钟都不能超过一个盘子。
# 补题
## 选拔赛1A（最大数）
```c++
#include<stdio.h>
#include<string.h>
#define MAXN 10
char a[MAXN][MAXN];
int dir[8][2] = { {-1,0},{0,1},{1,0},{0,-1},{-1,-1},{1,1},{1,-1},{-1,1} };
typedef long long ll;
int main()
{
	int n, cnt;
	scanf("%d", &n);
	getchar();
	for (int i = 0; i < n; i++)
		scanf("%s", a[i]);
	char max[MAXN + 1] = { 0 };
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
		{
			for (int k = 0; k < 8; k++)//八方
			{
				int dx = i, dy = j;
				char s[MAXN + 1] = { 0 };
				for (int l = 0; l < n; l++)//取串
				{
					s[l] = a[dx][dy];
					dx +=dir[k][0], dy += dir[k][1];
					if (dx == -1)
						dx = n - 1;
					if (dx == n)
						dx = 0;
					if (dy == -1)
						dy = n - 1;
					if (dy == n)
						dy = 0;
				}
				if (strcmp(max, s) < 0)
					strcpy(max, s);
			}
		}
	}
	printf("%s", max);
	return 0;
}
```
思路：遍历所有元素，将八个方向逐个比较求取最大值。
# 下周计划
尽量多补题，学会师哥教的dfs和bfs。
