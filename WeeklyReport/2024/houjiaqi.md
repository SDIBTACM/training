# 最短路-H 
给定一个包含 𝑛 个节点的有向图，请判断是否存在一个从节点 1 出发可以到达的负环。
负环的定义是：一个边的权重之和为负数的环。
输入
本题包含多组测试数据。
输入的第一行是一个整数 𝑇，表示测试数据的组数。对于每组数据，格式如下：
第一行包含两个整数，分别表示图的节点数 𝑛 和边的数量 𝑚。
接下来的 𝑚 行，每行包含三个整数 𝑢, 𝑣, 𝑤。
如果 𝑤 ≥ 0，则表示存在一条从 𝑢 到 𝑣 权重为 𝑤 的边，并且同时存在一条从 𝑣 到 𝑢 权重也为 𝑤 的边（即无向边）。
如果 𝑤 < 0，则表示仅存在一条从 𝑢 到 𝑣 权重为 𝑤 的边（即有向边）。
输出
对于每组测试数据，输出一行结果。如果存在从节点 1 出发可以到达的负环，则输出 "YES"，否则输出 "NO"。
题解：与课件中spfa算法一样，只不过多了一部分
```c++
if(z>=0)
            add(y,x,z);
```
# 基础dp A
如果一个数字序列a_i是有序的，那么它满足a_1 < a_2 < ... < a_N。给定一个数字序列(a_1, a_2, ..., a_N)的子序列是任何序列(a_{i1}, a_{i2}, ..., a_{iK})，其中1 <= i_1 < i_2 < ... < i_K <= N。例如，序列(1, 7, 3, 5, 9, 4, 8)有有序子序列，如(1, 7)，(3, 4, 8)等。所有最长的有序子序列的长度都是4，例如(1, 3, 5, 8)。

你的程序在给定一个数字序列后，必须找出其最长有序子序列的长度。
输入
输入文件的第一行包含序列的长度N。第二行包含序列的元素——N个在0到10000范围内的整数，由空格分隔。1 <= N <= 1000
输出
输出文件必须包含一个整数——给定序列的最长有序子序列的长度。
题解：动态规划+记忆化搜索，减少时间
```c++

#include <iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int n;
int a[1005];
int mem[1005]={0};
int dfs1(int i){
     if(mem[i])
        return mem[i];
     if(i==n)
        return 1;
     int max_len=1;
     for(int j=i+1;j<=n;j++)
        if(a[j]>a[i])
           max_len=max(max_len,dfs1(j)+1);
     mem[i]=max_len;
     return max_len;
}
int dfs2()
{
    int ans=1;
    for(int i=1; i<=n; i++)
        ans=max(dfs1(i),ans);
    return ans;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    cout<<dfs2();
    return 0;
}

```
# 基础dp-H 
小明想要在他的花店门口摆放一排花，总共有 m 盆花。他了解到顾客最喜欢的有 n 种花，每种花都有一个唯一的编号从 1 到 n。为了满足顾客的喜好和使展出更多样化，小明规定每种花 i 最多只能摆放 a_i 盆。在摆放时，同一种花必须放在一起，并且不同种类的花需要按照编号从小到大的顺序依次摆放。
现在，我们需要编写一个程序来计算有多少种不同的摆花方案。
题解：初始条件为：
dp[0][0] = 1（不使用任何花摆放 0 盆花有一种方案，即什么都不摆）。
其他 dp[0][j]（j > 0）和 dp[i][0]（i > 0）均为 0（因为不能摆放负数盆花，或者不使用任何花但要求摆放花）。
我们可以得到以下的递推关系：
如果不摆放第 i 种花，那么 dp[i][j] = dp[i-1][j]（即使用前 i-1 种花摆放 j 盆花）。
如果摆放第 i 种花，那么可以摆放 0 到 a_i 盆这种花。假设摆放了 k 盆（0 <= k <= a_i），那么剩下的 j-k 盆花可以用前 i-1 种花来摆放，即 dp[i][j] += dp[i-1][j-k]。
```c++
 memset(dp,0,sizeof(dp));
    dp[0][0] = 1;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 0; j <= m; j++)
        {
            for (int k = 0; k <= j&&k<=a[i]; k++)
            {
                dp[i][j] = (dp[i][j] + dp[i-1][j-k])%mod;
            }
        }
    }
```
